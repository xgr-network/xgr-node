name: Release (Integration + EEST + ForkGate + Publish)

on:
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Release tag (e.g. v1.2.3) - will be created only after all checks pass"
        required: true
      fork:
        description: "EEST fork (test selection ruleset)"
        required: true
        default: "Shanghai"
      tests_path:
        description: "Path inside execution-spec-tests repo"
        required: true
        default: "./tests/"
      pytest_k:
        description: "Optional pytest -k filter"
        required: false
        default: "not berlin and not osaka and not cancun and not prague and not withdrawals and not test_blockhash and not test_call.py and not test_precompile_absence.py and not test_scenarios.py"
      fork_gate_step:
        description: "ForkGate: compare every N blocks"
        required: false
        default: "1000"
      fork_gate_max_block:
        description: "ForkGate: max block (decimal). Empty = up to (remoteHead - lag)."
        required: false
        default: ""

concurrency:
  group: release-${{ github.event.inputs.release_tag }}
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  meta:
    name: Meta (validate tag)
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.v.outputs.version }}
    steps:
      - id: v
        run: |
          set -euo pipefail
          TAG="${{ github.event.inputs.release_tag }}"
          if [ -z "$TAG" ]; then echo "release_tag required"; exit 1; fi
          if [[ "$TAG" != v* ]]; then echo "release_tag must start with v (got: $TAG)"; exit 1; fi
          if ! [[ "$TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+([\-+].*)?$ ]]; then
            echo "release_tag should look like vX.Y.Z (got: $TAG)"
            exit 1
          fi
          echo "version=$TAG" >> "$GITHUB_OUTPUT"

  integration:
    name: Integration (unit + e2e + build)
    runs-on: ubuntu-latest
    timeout-minutes: 90
    needs: [meta]
    outputs:
      version: ${{ needs.meta.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-go@v5
        with:
          go-version: "1.23.x"
          cache: true

      - name: Go env
        run: |
          set -euo pipefail
          go version
          go env | sort

      - name: Go test (unit, full)
        run: |
          set -euo pipefail
          pkgs=$(go list ./... | grep -vE '(/e2e($|/)|/e2e-polybft($|/)|/tests($|/)|/tracker($|/)|/command/rootchain/deploy($|/)|/consensus/polybft($|/)|/state/runtime/evm($|/))')
          go test -count=1 $pkgs

      - name: Build node binary (release)
        env:
          VERSION: ${{ needs.meta.outputs.version }}
        run: |
          set -euo pipefail
          mkdir -p bin
          OUT="xgrchain-${VERSION}-linux-amd64"

          COMMIT="$(git rev-parse --short HEAD)"
          BRANCH="$(git rev-parse --abbrev-ref HEAD || true)"
          if [ "${BRANCH}" = "HEAD" ] || [ -z "${BRANCH}" ]; then
            BRANCH="${GITHUB_REF_NAME:-detached}"
          fi
          TIME="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          PKG="github.com/xgr-network/xgrchain/versioning"

          go build -trimpath -o "./bin/${OUT}" \
            -ldflags "-X ${PKG}.Version=${VERSION} -X ${PKG}.Commit=${COMMIT} -X ${PKG}.Branch=${BRANCH} -X ${PKG}.BuildTime=${TIME}" \
            .

          chmod +x "./bin/${OUT}"
          printf "%s\n" "${VERSION}" > ./bin/version.txt

          test -x "./bin/${OUT}"
          ls -lah "./bin/${OUT}" ./bin/version.txt
          file "./bin/${OUT}" || true

          echo "$PWD/bin" >> "$GITHUB_PATH"
          "./bin/${OUT}" version || true

      - name: E2E (watchdog + heartbeat)
        run: |
          set -euo pipefail

          echo "Starting E2E..."
          ( go test -v -count=1 -timeout 40m ./e2e/... ) &
          pid=$!
          echo "E2E pid=$pid"

          for i in $(seq 1 2700); do
            if ! kill -0 "$pid" 2>/dev/null; then
              echo "E2E finished, waiting..."
              wait "$pid"
              exit $?
            fi

            if [ $((i % 60)) -eq 0 ]; then
              echo "[heartbeat] $(date -u +'%Y-%m-%dT%H:%M:%SZ') e2e still running..."
              echo "== go/e2e procs =="
              ps -eo pid,ppid,stat,etimes,cmd | egrep -i 'go test|e2e\.test|xgrchain' | head -n 50 || true
              echo "== ports :12000-:12030 =="
              ss -ltnp | awk '$4 ~ /:120(0[0-9]|1[0-9]|2[0-9]|30)$/ {print}' || true
              echo "== tmp dirs (latest) =="
              ls -1dt /tmp/polygon-edge-e2e-* 2>/dev/null | head -n 3 || true
              latest="$(ls -1dt /tmp/polygon-edge-e2e-* 2>/dev/null | head -n 1 || true)"
              if [ -n "$latest" ]; then
                echo "== latest tmp files (mtime) =="
                find "$latest" -maxdepth 2 -type f -printf '%TY-%Tm-%TdT%TH:%TM:%TS %p\n' 2>/dev/null | sort -r | head -n 15 || true
              fi
            fi

            sleep 1
          done

          echo "ERROR: E2E exceeded watchdog (45m) - killing..."
          kill "$pid" || true
          sleep 2
          kill -9 "$pid" || true
          exit 1


          echo "ERROR: E2E exceeded watchdog (45m) - killing..."
          kill "$pid" || true
          sleep 2
          kill -9 "$pid" || true
          exit 1

      - name: Cleanup stray xgrchain
        if: always()
        run: |
          set -euo pipefail
          pkill -9 xgrchain || true

      - name: Upload binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: xgrchain-release
          path: |
            ./bin/xgrchain-${{ needs.meta.outputs.version }}-linux-amd64
            ./bin/version.txt
          retention-days: 14

  eest:
    name: EEST (execution-spec-tests)
    runs-on: ubuntu-latest
    timeout-minutes: 360
    needs: [meta]
    env:
      FORK: ${{ github.event.inputs.fork }}
      TESTS_PATH: ${{ github.event.inputs.tests_path }}
      PYTEST_K: ${{ github.event.inputs.pytest_k }}
      RPC: "http://127.0.0.1:8545"
      CHAIN_ID: "100"
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-go@v5
        with:
          go-version: "1.23.x"
          cache: true

      - name: Install deps (jq, curl)
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: Patch MinBaseFee for CI (EEST)
        run: |
          set -euo pipefail
          perl -pi -e 's/(MinBaseFee\s+uint64\s*=\s*)[0-9_]+/${1}1/' chain/params.go
          grep -n "MinBaseFee" chain/params.go

      - name: Build xgrchain (for local EEST node)
        run: |
          set -euo pipefail
          mkdir -p bin
          go build -trimpath -o ./bin/xgrchain .
          chmod +x ./bin/xgrchain
          echo "${GITHUB_WORKSPACE}/bin" >> "$GITHUB_PATH"
          ./bin/xgrchain version || true

      - name: Generate ephemeral EEST seed key (PK + address)
        run: |
          set -euo pipefail
          cat > /tmp/keygen.go <<'GO'
          package main
          import (
            "encoding/hex"
            "fmt"
            "github.com/ethereum/go-ethereum/crypto"
          )
          func main() {
            k, err := crypto.GenerateKey()
            if err != nil { panic(err) }
            pk := crypto.FromECDSA(k)
            addr := crypto.PubkeyToAddress(k.PublicKey)
            fmt.Printf("SEED_KEY=0x%s\n", hex.EncodeToString(pk))
            fmt.Printf("SEED_ADDR=%s\n", addr.Hex())
          }
          GO
          out="$(go run /tmp/keygen.go)"
          echo "$out"
          echo "$out" >> "$GITHUB_ENV"

      - name: Create IBFT validator secrets (single node) + derive bootnode
        run: |
          set -euo pipefail
          rm -rf ./validator-1
          mkdir -p ./validator-1
          OUT="$(xgrchain secrets init --data-dir ./validator-1 --insecure --json)"
          echo "$OUT" | jq . || true
          NODE_ID="$(
            echo "$OUT" | jq -r '
              if type=="array" then (.[0].node_id // .[0].nodeID // empty)
              else (.node_id // .nodeID // empty)
              end
            '
          )"
          if [ -z "$NODE_ID" ] || [ "$NODE_ID" = "null" ]; then
            echo "ERROR: could not determine node_id for bootnode"
            echo "$OUT"
            exit 1
          fi
          echo "BOOTNODE=/ip4/127.0.0.1/tcp/1478/p2p/${NODE_ID}" >> "$GITHUB_ENV"

      - name: Generate genesis (IBFT + premine EEST seed)
        env:
          PREMINE_WEI: "1000000000000000000000000000"
        run: |
          set -euo pipefail
          xgrchain genesis \
            --consensus ibft \
            --chain-id "${CHAIN_ID}" \
            --block-time 1s \
            --block-gas-limit 22500000 \
            --base-fee-config 1000000000:2:8 \
            --bootnode "${BOOTNODE}" \
            --premine "${SEED_ADDR}:${PREMINE_WEI}" \
            --validators-path ./ \
            --validators-prefix validator- \
            --min-validator-count 1 \
            --max-validator-count 1 \
            --name eest \
            --dir ./genesis-eest.json

          jq '
            (.params.forks |= with_entries(.value |= (if (.block? != null) then (.block=0) else . end))) |
            (.alloc = .genesis.alloc)
          ' ./genesis-eest.json > ./genesis-eest.tmp && mv ./genesis-eest.tmp ./genesis-eest.json
          test -s ./genesis-eest.json

      - name: Start local node (JSON-RPC) + RPC sanity
        run: |
          set -euo pipefail

          xgrchain server \
            --data-dir ./validator-1 \
            --chain ./genesis-eest.json \
            --grpc-address 127.0.0.1:9632 \
            --libp2p 127.0.0.1:1478 \
            --jsonrpc 127.0.0.1:8545 \
            --price-limit 0 \
            --seal \
            --log-level INFO \
            --log-to node.log &
          echo $! > /tmp/eest-node.pid

          rpc_call() {
            local method="$1"
            local params="${2:-[]}"
            curl -sS -X POST "${RPC}" \
              -H 'content-type: application/json' \
              --data "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"${method}\",\"params\":${params}}"
          }

          # RPC up?
          for i in {1..120}; do
            if rpc_call eth_chainId | jq -e .result >/dev/null 2>&1; then
              break
            fi
            sleep 1
          done

          echo "eth_chainId=$(rpc_call eth_chainId | jq -r .result)"
          echo "eth_blockNumber=$(rpc_call eth_blockNumber | jq -r .result)"

          # Ensure blocks move (sealing actually happens)
          last="$(rpc_call eth_blockNumber | jq -r .result)"
          for i in {1..40}; do
            sleep 1
            cur="$(rpc_call eth_blockNumber | jq -r .result)"
            if [ "$cur" != "$last" ]; then
              echo "block advanced: ${last} -> ${cur}"
              exit 0
            fi
          done

          echo "ERROR: blockNumber did not advance within 40s (sealing issue). Dumping log:"
          tail -n 200 node.log || true
          exit 1

      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Setup uv
        uses: astral-sh/setup-uv@v7

      - name: Clone execution-spec-tests
        run: |
          set -euo pipefail
          git clone --depth 1 https://github.com/ethereum/execution-spec-tests.git eest

      - name: Run EEST (execute remote)
        run: |
          set -euo pipefail
          cd eest
          extra_args=()
          if [ -n "${PYTEST_K}" ]; then
            extra_args+=(-k "${PYTEST_K}")
          fi
          uv run execute remote \
            --fork "${FORK}" \
            --rpc-endpoint "${RPC}" \
            --rpc-seed-key "${SEED_KEY}" \
            --rpc-chain-id "${CHAIN_ID}" \
            "${TESTS_PATH}" \
            "${extra_args[@]}"

      - name: Upload node log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: eest-node-log
          path: node.log
          retention-days: 14

  fork_gate:
    name: Fork Gate (sync + blockhash parity)
    runs-on: ubuntu-latest
    timeout-minutes: 360
    needs: [integration]
    env:
      REF_RPC: "https://rpc1.xgr.network"
      GENESIS_URL: "https://raw.githubusercontent.com/xgr-network/XGR/main/genesis/mainnet/genesis.json"
      LOCAL_RPC: "http://127.0.0.1:8545"
      HEAD_LAG: "20"
      SYNC_POLL_SEC: "5"
      SYNC_TIMEOUT_SEC: "21600"
      STEP: ${{ github.event.inputs.fork_gate_step }}
      MAX_BLOCK_INPUT: ${{ github.event.inputs.fork_gate_max_block }}
    steps:
      - name: Install deps (jq, curl)
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: Download built binary
        uses: actions/download-artifact@v4
        with:
          name: xgrchain-release
          path: dist

      - name: Prepare binary
        run: |
          set -euo pipefail
          BIN="$(ls -1 dist/xgrchain-*-linux-amd64 | head -n1)"
          test -n "$BIN"
          chmod +x "$BIN"
          mkdir -p bin
          cp "$BIN" ./bin/xgrchain
          chmod +x ./bin/xgrchain
          ./bin/xgrchain version || true
          file ./bin/xgrchain || true

      - name: Fetch mainnet genesis.json
        run: |
          set -euo pipefail
          curl -fsSL "${GENESIS_URL}" -o ./genesis.json
          test -s ./genesis.json
          jq . ./genesis.json >/dev/null

      - name: Start local sync node
        run: |
          set -euo pipefail
          rm -rf ./forkgate
          mkdir -p ./forkgate
          ./bin/xgrchain server \
            --data-dir ./forkgate \
            --chain ./genesis.json \
            --grpc-address 127.0.0.1:9632 \
            --libp2p 127.0.0.1:1478 \
            --jsonrpc 127.0.0.1:8545 \
            --price-limit 0 \
            --log-level WARN \
            --log-to fork-gate-node.log &
          echo $! > /tmp/forkgate.pid

          for i in {1..180}; do
            curl -sS -X POST "${LOCAL_RPC}" \
              -H 'content-type: application/json' \
              --data '{"jsonrpc":"2.0","id":1,"method":"eth_chainId","params":[]}' \
              | jq -e .result >/dev/null 2>&1 && break
            sleep 1
          done

          echo "LOCAL eth_chainId=$(curl -sS -X POST "${LOCAL_RPC}" -H 'content-type: application/json' --data '{"jsonrpc":"2.0","id":1,"method":"eth_chainId","params":[]}' | jq -r .result)"
          echo "REF   eth_chainId=$(curl -sS -X POST "${REF_RPC}"  -H 'content-type: application/json' --data '{"jsonrpc":"2.0","id":1,"method":"eth_chainId","params":[]}' | jq -r .result)"

      - name: Fork parity check (sync + blockhash every N blocks)
        run: |
          set -euo pipefail

          rpc() {
            local url="$1"
            local method="$2"
            local params="${3:-[]}"
            curl -sS -X POST "${url}" \
              -H 'content-type: application/json' \
              --data "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"${method}\",\"params\":${params}}"
          }

          hex_to_dec() {
            local h="$1"
            h="${h#0x}"
            if [ -z "$h" ] || [ "$h" = "null" ]; then echo ""; return 1; fi
            echo $((16#$h))
          }

          dec_to_hex() {
            printf "0x%x" "$1"
          }

          # Determine remote head
          remoteHeadHex="$(rpc "${REF_RPC}" eth_blockNumber | jq -r .result)"
          remoteHead="$(hex_to_dec "${remoteHeadHex}")"
          if [ -z "${remoteHead}" ]; then
            echo "ERROR: cannot read remote head"
            rpc "${REF_RPC}" eth_blockNumber | jq .
            exit 1
          fi

          headLag="${HEAD_LAG}"
          if ! [[ "$headLag" =~ ^[0-9]+$ ]]; then headLag=20; fi

          if [ -n "${MAX_BLOCK_INPUT}" ]; then
            if ! [[ "${MAX_BLOCK_INPUT}" =~ ^[0-9]+$ ]]; then
              echo "ERROR: fork_gate_max_block must be decimal (got: ${MAX_BLOCK_INPUT})"
              exit 1
            fi
            maxBlock="${MAX_BLOCK_INPUT}"
          else
            if [ "${remoteHead}" -le "${headLag}" ]; then
              maxBlock=0
            else
              maxBlock=$((remoteHead - headLag))
            fi
          fi

          step="${STEP}"
          if ! [[ "$step" =~ ^[0-9]+$ ]] || [ "$step" -le 0 ]; then step=1000; fi

          echo "Remote head: ${remoteHead} (hex ${remoteHeadHex})"
          echo "Max block : ${maxBlock} (remoteHead - lag=${headLag}, unless overridden)"
          echo "Step      : ${step}"

          # Sync wait
          startTs="$(date +%s)"
          lastBlock=-1
          lastProgressTs="$(date +%s)"

          while true; do
            now="$(date +%s)"
            if [ $((now - startTs)) -ge "${SYNC_TIMEOUT_SEC}" ]; then
              echo "ERROR: sync timeout after ${SYNC_TIMEOUT_SEC}s"
              echo "== local status =="
              rpc "${LOCAL_RPC}" eth_syncing | jq . || true
              rpc "${LOCAL_RPC}" eth_blockNumber | jq . || true
              echo "== processes =="
              ps -ef | grep -E '[x]grchain' || true
              echo "== ports =="
              ss -ltnp | grep -E ':(8545|9632|1478)\b' || true
              echo "== last log =="
              tail -n 200 fork-gate-node.log || true
              exit 1
            fi

            localHex="$(rpc "${LOCAL_RPC}" eth_blockNumber | jq -r .result)"
            localDec="$(hex_to_dec "${localHex}" || true)"
            if [ -z "${localDec}" ]; then
              echo "WARN: cannot read local blockNumber yet"
              sleep "${SYNC_POLL_SEC}"
              continue
            fi

            if [ "${localDec}" -ne "${lastBlock}" ]; then
              lastBlock="${localDec}"
              lastProgressTs="$(date +%s)"
            fi

            if [ $(( (now - startTs) % 60 )) -lt "${SYNC_POLL_SEC}" ]; then
              syncing="$(rpc "${LOCAL_RPC}" eth_syncing | jq -r '.result | (if type=="boolean" then tostring else "true" end)' || true)"
              echo "[sync] t=$((now-startTs))s local=${localDec} max=${maxBlock} syncing=${syncing}"
            fi

            # If no progress for 10 minutes -> fail fast with diagnostics
            if [ $((now - lastProgressTs)) -ge 600 ]; then
              echo "ERROR: no sync progress for 600s (stalled)."
              rpc "${LOCAL_RPC}" eth_syncing | jq . || true
              rpc "${LOCAL_RPC}" net_peerCount | jq . || true
              tail -n 200 fork-gate-node.log || true
              exit 1
            fi

            if [ "${localDec}" -ge "${maxBlock}" ]; then
              echo "Synced enough: local=${localDec} >= max=${maxBlock}"
              break
            fi

            sleep "${SYNC_POLL_SEC}"
          done

          # Parity check
          echo "Starting parity check..."
          for ((b=0; b<=maxBlock; b+=step)); do
            hb="$(dec_to_hex "${b}")"
            rHash="$(rpc "${REF_RPC}"   eth_getBlockByNumber "[\"${hb}\", false]" | jq -r .result.hash)"
            lHash="$(rpc "${LOCAL_RPC}" eth_getBlockByNumber "[\"${hb}\", false]" | jq -r .result.hash)"

            if [ -z "${rHash}" ] || [ "${rHash}" = "null" ]; then
              echo "ERROR: remote block ${b} (${hb}) missing hash"
              rpc "${REF_RPC}" eth_getBlockByNumber "[\"${hb}\", false]" | jq .
              exit 1
            fi
            if [ -z "${lHash}" ] || [ "${lHash}" = "null" ]; then
              echo "ERROR: local block ${b} (${hb}) missing hash"
              rpc "${LOCAL_RPC}" eth_getBlockByNumber "[\"${hb}\", false]" | jq .
              echo "== last log =="
              tail -n 200 fork-gate-node.log || true
              exit 1
            fi

            if [ "${rHash}" != "${lHash}" ]; then
              echo "ERROR: HASH MISMATCH at block ${b} (${hb})"
              echo "  remote: ${rHash}"
              echo "  local : ${lHash}"
              echo "== remote block =="
              rpc "${REF_RPC}"   eth_getBlockByNumber "[\"${hb}\", false]" | jq .
              echo "== local block =="
              rpc "${LOCAL_RPC}" eth_getBlockByNumber "[\"${hb}\", false]" | jq .
              echo "== last log =="
              tail -n 200 fork-gate-node.log || true
              exit 1
            fi

            if [ $((b % (step*10) )) -eq 0 ]; then
              echo "[parity] ok up to block ${b} (${hb}) hash=${lHash}"
            fi
          done

          echo "ForkGate PASS (0..${maxBlock} step=${step})"

      - name: Upload fork gate node log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: fork-gate-node-log
          path: fork-gate-node.log
          retention-days: 14

  publish_release:
    name: Publish release
    runs-on: ubuntu-latest
    needs: [meta, integration, eest, fork_gate]
    if: ${{ needs.integration.result == 'success' && needs.eest.result == 'success' && needs.fork_gate.result == 'success' }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: xgrchain-release
          path: dist

      - name: Create checksums
        run: |
          set -euo pipefail
          cd dist
          sha256sum * > sha256sums.txt
          ls -lah
          cat sha256sums.txt

      - name: Fail if tag already exists
        uses: actions/github-script@v7
        with:
          script: |
            const tag = `${{ needs.meta.outputs.version }}`.trim();
            try {
              await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `tags/${tag}`,
              });
              core.setFailed(`tag already exists: ${tag}`);
            } catch (e) {
              if (e.status !== 404) throw e;
              core.info(`tag does not exist yet: ${tag}`);
            }

      - name: Create Release (creates tag on this commit)
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ needs.meta.outputs.version }}
          name: ${{ needs.meta.outputs.version }}
          prerelease: false
          allowUpdates: false
          makeLatest: true
          commit: ${{ github.sha }}
          body: |
            Release build.
            Version: ${{ needs.meta.outputs.version }}
            Commit:  ${{ github.sha }}
          artifacts: |
            dist/*
