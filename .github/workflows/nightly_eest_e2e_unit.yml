name: Nightly (Integration + EEST + Release)

on:
  schedule:
    - cron: "0 3 * * *" # daily 03:00 UTC
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Optional release tag to create on success (e.g. v1.2.3). Leave empty for nightly."
        required: false
        default: ""
      fork:
        description: "EEST fork (test selection ruleset)"
        required: true
        default: "Shanghai"
      tests_path:
        description: "Path inside execution-spec-tests repo"
        required: true
        default: "./tests/"
      pytest_k:
        description: "Optional pytest -k filter (use sparingly; better use tests_path)"
        required: false
        default: "not berlin and not osaka and not cancun and not prague and not withdrawals and not test_blockhash and not test_call.py and not test_precompile_absence.py and not test_scenarios.py"
      fork_gate_step:
        description: "Fork gate: verify every N blocks (and only then print output). Only used for release runs."
        required: false
        default: "1000"
      fork_gate_head_lag:
        description: "Fork gate: compare up to (remoteHead - LAG). Only used for release runs."
        required: false
        default: "20"
  push:
    tags:
      - "v*"

concurrency:
  group: nightly-main
  cancel-in-progress: true

permissions:
  contents: write

jobs:
  meta:
    name: Meta (version)
    runs-on: ubuntu-latest
    if: ${{ !(github.actor == 'github-actions[bot]' && startsWith(github.ref, 'refs/tags/')) }}
    outputs:
      version: ${{ steps.v.outputs.version }}
      release_tag: ${{ steps.v.outputs.release_tag }}
      prerelease: ${{ steps.v.outputs.prerelease }}
      make_latest: ${{ steps.v.outputs.make_latest }}
      is_nightly: ${{ steps.v.outputs.is_nightly }}
      create_tag: ${{ steps.v.outputs.create_tag }}
    steps:
      - name: Compute version (tag push / manual tag / nightly)
        id: v
        run: |
          set -euo pipefail

          REL="${{ github.event.inputs.release_tag }}"

          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            VERSION="${GITHUB_REF_NAME}"
            RELEASE_TAG="${GITHUB_REF_NAME}"
            PRERELEASE="false"
            MAKE_LATEST="true"
            IS_NIGHTLY="false"
            CREATE_TAG="false"
          elif [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" && -n "${REL}" ]]; then
            VERSION="${REL}"
            RELEASE_TAG="${REL}"
            PRERELEASE="false"
            MAKE_LATEST="true"
            IS_NIGHTLY="false"
            CREATE_TAG="true"
          else
            SHA="${GITHUB_SHA::7}"
            DATE="$(date -u +%Y%m%d)"
            VERSION="nightly-${DATE}-${SHA}"
            RELEASE_TAG="nightly"
            PRERELEASE="true"
            MAKE_LATEST="false"
            IS_NIGHTLY="true"
            CREATE_TAG="false"
          fi

          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "release_tag=$RELEASE_TAG" >> "$GITHUB_OUTPUT"
          echo "prerelease=$PRERELEASE" >> "$GITHUB_OUTPUT"
          echo "make_latest=$MAKE_LATEST" >> "$GITHUB_OUTPUT"
          echo "is_nightly=$IS_NIGHTLY" >> "$GITHUB_OUTPUT"
          echo "create_tag=$CREATE_TAG" >> "$GITHUB_OUTPUT"

  integration:
    name: Integration (unit + e2e + build)
    runs-on: ubuntu-latest
    timeout-minutes: 90
    needs: [meta]
    if: ${{ !(github.actor == 'github-actions[bot]' && startsWith(github.ref, 'refs/tags/')) }}
    outputs:
      version: ${{ needs.meta.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-go@v5
        with:
          go-version: "1.23.x"
          cache: true

      - name: Go test (unit, full)
        run: |
          set -euo pipefail
          pkgs=$(go list ./... | grep -vE '(/e2e($|/)|/e2e-polybft($|/)|/tests($|/)|/tracker($|/)|/command/rootchain/deploy($|/)|/consensus/polybft($|/)|/state/runtime/evm($|/))')
          go test -count=1 $pkgs

      - name: Build node binary (versioned + ldflags)
        env:
          VERSION: ${{ needs.meta.outputs.version }}
        run: |
          set -euo pipefail
          mkdir -p bin
          OUT="xgrchain-${VERSION}-linux-amd64"

          COMMIT="$(git rev-parse --short HEAD)"
          BRANCH="$(git rev-parse --abbrev-ref HEAD || true)"
          if [ "${BRANCH}" = "HEAD" ] || [ -z "${BRANCH}" ]; then
            BRANCH="${GITHUB_REF_NAME:-detached}"
          fi
          TIME="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          PKG="github.com/xgr-network/xgrchain/versioning"

          go build -trimpath -o "./bin/${OUT}" \
            -ldflags "-X ${PKG}.Version=${VERSION} -X ${PKG}.Commit=${COMMIT} -X ${PKG}.Branch=${BRANCH} -X ${PKG}.BuildTime=${TIME}" \
            .

          cp "./bin/${OUT}" "./bin/xgrchain"
          chmod +x "./bin/xgrchain" "./bin/${OUT}" || true
          echo "$PWD/bin" >> "$GITHUB_PATH"
          ./bin/xgrchain version || ./bin/xgrchain --version || true
          printf "%s\n" "${VERSION}" > ./bin/version.txt

      - name: E2E
        run: go test -count=1 -timeout 45m ./e2e/...

      - name: Upload nightly binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: xgrchain-nightly-linux-amd64
          path: |
            ./bin/xgrchain-${{ needs.meta.outputs.version }}-linux-amd64
            ./bin/version.txt
          retention-days: 14

  eest:
    name: EEST (execution-spec-tests)
    runs-on: ubuntu-latest
    timeout-minutes: 360
    needs: [meta]
    if: ${{ !(github.actor == 'github-actions[bot]' && startsWith(github.ref, 'refs/tags/')) }}
    env:
      FORK: ${{ github.event.inputs.fork || 'Shanghai' }}
      TESTS_PATH: ${{ github.event.inputs.tests_path || './tests/shanghai/' }}
      PYTEST_K: ${{ github.event.inputs.pytest_k || 'not withdrawals' }}
      RPC: "http://127.0.0.1:8545"
      CHAIN_ID: "100"
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-go@v5
        with:
          go-version: "1.23.x"
          cache: true

      - name: Install deps (jq, curl)
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: Patch MinBaseFee for CI (EEST)
        run: |
          set -euo pipefail
          perl -pi -e 's/(MinBaseFee\s+uint64\s*=\s*)[0-9_]+/${1}1/' chain/params.go
          grep -n "MinBaseFee" chain/params.go

      - name: Build xgrchain (for local EEST node)
        run: |
          set -euo pipefail
          mkdir -p bin
          go build -trimpath -o ./bin/xgrchain .
          chmod +x ./bin/xgrchain
          echo "${GITHUB_WORKSPACE}/bin" >> "$GITHUB_PATH"

      - name: Generate ephemeral EEST seed key (PK + address)
        run: |
          set -euo pipefail
          cat > /tmp/keygen.go <<'GO'
          package main
          import (
            "encoding/hex"
            "fmt"
            "github.com/ethereum/go-ethereum/crypto"
          )
          func main() {
            k, err := crypto.GenerateKey()
            if err != nil { panic(err) }
            pk := crypto.FromECDSA(k)
            addr := crypto.PubkeyToAddress(k.PublicKey)
            fmt.Printf("SEED_KEY=0x%s\n", hex.EncodeToString(pk))
            fmt.Printf("SEED_ADDR=%s\n", addr.Hex())
          }
          GO
          out="$(go run /tmp/keygen.go)"
          echo "$out"
          echo "$out" >> "$GITHUB_ENV"

      - name: Create IBFT validator secrets (single node) + derive bootnode
        run: |
          set -euo pipefail
          rm -rf ./validator-1
          mkdir -p ./validator-1
          OUT="$(xgrchain secrets init --data-dir ./validator-1 --insecure --json)"
          echo "$OUT" | jq . || true
          NODE_ID="$(
            echo "$OUT" | jq -r '
              if type=="array" then (.[0].node_id // .[0].nodeID // empty)
              else (.node_id // .nodeID // empty)
              end
            '
          )"
          if [ -z "$NODE_ID" ] || [ "$NODE_ID" = "null" ]; then
            echo "ERROR: could not determine node_id for bootnode"
            echo "$OUT"
            exit 1
          fi
          echo "BOOTNODE=/ip4/127.0.0.1/tcp/1478/p2p/${NODE_ID}" >> "$GITHUB_ENV"

      - name: Generate genesis (IBFT + premine EEST seed)
        env:
          PREMINE_WEI: "1000000000000000000000000000"
        run: |
          set -euo pipefail
          xgrchain genesis \
            --consensus ibft \
            --chain-id "${CHAIN_ID}" \
            --block-time 1s \
            --block-gas-limit 22500000 \
            --base-fee-config 1000000000:2:8 \
            --bootnode "${BOOTNODE}" \
            --premine "${SEED_ADDR}:${PREMINE_WEI}" \
            --validators-path ./ \
            --validators-prefix validator- \
            --min-validator-count 1 \
            --max-validator-count 1 \
            --name eest \
            --dir ./genesis-eest.json
          jq '
            (.params.forks |= with_entries(.value |= (if (.block? != null) then (.block=0) else . end))) |
            (.alloc = .genesis.alloc)
          ' ./genesis-eest.json > ./genesis-eest.tmp && mv ./genesis-eest.tmp ./genesis-eest.json
          test -s ./genesis-eest.json

      - name: Start local node (JSON-RPC)
        run: |
          set -euo pipefail
          xgrchain server \
            --data-dir ./validator-1 \
            --chain ./genesis-eest.json \
            --grpc-address 127.0.0.1:9632 \
            --libp2p 127.0.0.1:1478 \
            --jsonrpc 127.0.0.1:8545 \
            --price-limit 0 \
            --seal \
            --log-level INFO \
            --log-to node.log &
          for i in {1..90}; do
            curl -sS -X POST http://127.0.0.1:8545 \
              -H 'content-type: application/json' \
              --data '{"jsonrpc":"2.0","id":1,"method":"eth_chainId","params":[]}' >/dev/null && break
            sleep 1
          done

      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Setup uv
        uses: astral-sh/setup-uv@v7

      - name: Clone execution-spec-tests
        run: |
          set -euo pipefail
          git clone --depth 1 https://github.com/ethereum/execution-spec-tests.git eest

      - name: Run EEST (execute remote)
        run: |
          set -euo pipefail
          cd eest
          extra_args=()
          if [ -n "${PYTEST_K}" ]; then
            extra_args+=(-k "${PYTEST_K}")
          fi
          uv run execute remote \
            --fork "${FORK}" \
            --rpc-endpoint "${RPC}" \
            --rpc-seed-key "${SEED_KEY}" \
            --rpc-chain-id "${CHAIN_ID}" \
            "${TESTS_PATH}" \
            "${extra_args[@]}"

      - name: Upload node log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: eest-node-log
          path: node.log
          retention-days: 14

  fork_gate:
    name: Fork Gate (sync + blockhash parity)
    runs-on: ubuntu-latest
    timeout-minutes: 240
    needs: [meta, integration]
    if: ${{ needs.meta.outputs.is_nightly != 'true' && !(github.actor == 'github-actions[bot]' && startsWith(github.ref, 'refs/tags/')) }}
    env:
      REF_RPC: "https://rpc1.xgr.network"
      GENESIS_URL: "https://raw.githubusercontent.com/xgr-network/XGR/main/genesis/mainnet/genesis.json"
      LOCAL_RPC: "http://127.0.0.1:8545"
      HEAD_LAG: ${{ github.event.inputs.fork_gate_head_lag || '20' }}
      STEP: ${{ github.event.inputs.fork_gate_step || '1000' }}
      SYNC_TIMEOUT_SEC: "10800" # 3h
    steps:
      - name: Install deps (jq, curl)
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: Download built binary (from integration)
        uses: actions/download-artifact@v4
        with:
          name: xgrchain-nightly-linux-amd64
          path: dist

      - name: Prepare binary
        run: |
          set -euo pipefail
          ls -la dist
          BIN="$(ls -1 dist/xgrchain-*-linux-amd64 | head -n1)"
          test -n "$BIN"
          chmod +x "$BIN"
          mkdir -p bin
          cp "$BIN" ./bin/xgrchain
          chmod +x ./bin/xgrchain
          ./bin/xgrchain version || ./bin/xgrchain --version || true

      - name: Fetch mainnet genesis.json
        run: |
          set -euo pipefail
          curl -fsSL "${GENESIS_URL}" -o ./genesis.json
          test -s ./genesis.json
          if grep -qE '^\s*//tbd\s*$' ./genesis.json; then
            echo "ERROR: genesis.json at ${GENESIS_URL} is placeholder ('//tbd')."
            exit 1
          fi
          jq . ./genesis.json >/dev/null

      - name: Start local sync node (silent)
        run: |
          set -euo pipefail
          rm -rf ./forkgate
          mkdir -p ./forkgate

          ./bin/xgrchain server \
            --data-dir ./forkgate \
            --chain ./genesis.json \
            --grpc-address 127.0.0.1:9632 \
            --libp2p 127.0.0.1:1478 \
            --jsonrpc 127.0.0.1:8545 \
            --price-limit 0 \
            --log-level INFO \
            --log-to fork-gate-node.log &

          for i in {1..120}; do
            curl -sS -X POST "${LOCAL_RPC}" \
              -H 'content-type: application/json' \
              --data '{"jsonrpc":"2.0","id":1,"method":"eth_chainId","params":[]}' >/dev/null && break
            sleep 1
          done

      - name: Fork parity check (only prints on checkpoints)
        run: |
          set -euo pipefail

          rpc_call () {
            local url="$1"; shift
            local method="$1"; shift
            local params="${1:-[]}"
            curl -fsSL -X POST "$url" \
              -H 'content-type: application/json' \
              --data "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"${method}\",\"params\":${params}}" \
              | jq -r '.result'
          }

          i64 () { python3 -c 'import sys; print(int(sys.argv[1],16))' "$1"; }
          hx () { python3 -c 'import sys; print(hex(int(sys.argv[1])))' "$1"; }

          block_hash () {
            local url="$1"
            local n="$2"
            local num; num="$(hx "$n")"
            local obj; obj="$(rpc_call "$url" eth_getBlockByNumber "[\"${num}\",false]")"
            if [ -z "$obj" ] || [ "$obj" = "null" ]; then
              echo ""
              return 1
            fi
            echo "$obj" | jq -r '.hash'
          }

          # Remote head / target
          remote_head_hex="$(rpc_call "${REF_RPC}" eth_blockNumber '[]')"
          remote_head="$(i64 "${remote_head_hex}")"
          lag="${HEAD_LAG}"
          if [ "$remote_head" -le "$lag" ]; then
            echo "ERROR: remote head too small? head=${remote_head}"
            exit 1
          fi
          target=$((remote_head - lag))
          step="${STEP}"

          echo "ForkGate config: head=${remote_head} target=${target} step=${step} lag=${lag}"

          # wait until local catches up to target (timeout)
          deadline=$(( $(date +%s) + ${SYNC_TIMEOUT_SEC} ))

          wait_local_ge () {
            local want="$1"
            while true; do
              if [ "$(date +%s)" -ge "$deadline" ]; then
                echo "ERROR: sync timeout before reaching ${want}"
                exit 1
              fi
              local_head_hex="$(rpc_call "${LOCAL_RPC}" eth_blockNumber '[]' || echo "0x0")"
              local_head="$(i64 "${local_head_hex}")"
              [ "$local_head" -ge "$want" ] && return 0
              sleep 2
            done
          }

          # Chain identity (genesis must match)
          b0="$(block_hash "${REF_RPC}" 0 || true)"
          l0="$(block_hash "${LOCAL_RPC}" 0 || true)"
          if [ -z "$b0" ] || [ -z "$l0" ]; then
            echo "ERROR: cannot read block 0 from one of the RPCs"
            exit 1
          fi
          if [ "$b0" != "$l0" ]; then
            echo "FAIL: genesis mismatch"
            echo "  ref  : $b0"
            echo "  local: $l0"
            exit 1
          fi
          echo "OK: genesis hash matches ($b0)"

          # binary search first bad block between (lo ok, hi bad)
          bisect_first_bad () {
            local lo="$1" hi="$2"
            while [ $((hi - lo)) -gt 1 ]; do
              local mid=$(((lo + hi) / 2))
              wait_local_ge "$mid"
              local rh lh
              rh="$(block_hash "${REF_RPC}" "$mid" || true)"
              lh="$(block_hash "${LOCAL_RPC}" "$mid" || true)"
              if [ -n "$rh" ] && [ -n "$lh" ] && [ "$rh" = "$lh" ]; then
                lo="$mid"
              else
                hi="$mid"
              fi
            done
            echo "$hi"
          }

          checks=0
          last_ok=0

          # checkpoints from 0..target in STEP increments (only output here)
          for ((n=0; n<=target; n+=step)); do
            wait_local_ge "$n"
            rh="$(block_hash "${REF_RPC}" "$n" || true)"
            lh="$(block_hash "${LOCAL_RPC}" "$n" || true)"
            if [ -z "$rh" ] || [ -z "$lh" ]; then
              echo "FAIL: missing block at n=${n} (ref='${rh:-}' local='${lh:-}')"
              exit 1
            fi
            if [ "$rh" != "$lh" ]; then
              echo "FAIL: fork mismatch at checkpoint n=${n}"
              echo "  ref  : $rh"
              echo "  local: $lh"
              bad="$(bisect_first_bad "$last_ok" "$n")"
              echo "FAIL: first bad block â‰ˆ ${bad}"
              exit 1
            fi
            checks=$((checks + 1))
            last_ok="$n"
            echo "CHECK OK: n=${n} hash=${rh}"
          done

          # always check target explicitly too (even if not aligned to step)
          wait_local_ge "$target"
          rh="$(block_hash "${REF_RPC}" "$target" || true)"
          lh="$(block_hash "${LOCAL_RPC}" "$target" || true)"
          if [ -z "$rh" ] || [ -z "$lh" ] || [ "$rh" != "$lh" ]; then
            echo "FAIL: fork mismatch at target=${target}"
            echo "  ref  : ${rh:-}"
            echo "  local: ${lh:-}"
            exit 1
          fi

          echo "PASS: Fork Gate OK (checks=${checks}, target=${target})"

      - name: Upload fork gate node log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: fork-gate-node-log
          path: fork-gate-node.log
          retention-days: 14

  publish:
    name: Publish nightly release
    runs-on: ubuntu-latest
    needs: [meta, integration, eest, fork_gate]
    if: ${{ needs.integration.result == 'success' && needs.eest.result == 'success' && (needs.meta.outputs.is_nightly == 'true' || needs.fork_gate.result == 'success') && !(github.actor == 'github-actions[bot]' && startsWith(github.ref, 'refs/tags/')) }}
    permissions:
      contents: write
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: xgrchain-nightly-linux-amd64
          path: dist

      - name: Create checksums
        run: |
          set -euo pipefail
          cd dist
          sha256sum * > sha256sums.txt

      - name: Create git tag (manual tagged runs only)
        if: ${{ needs.meta.outputs.create_tag == 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const tag = `${{ needs.meta.outputs.release_tag }}`.trim();
            if (!tag) core.setFailed("release_tag is empty");
            if (!tag.startsWith("v")) core.setFailed(`release_tag must start with 'v' (got: ${tag})`);

            // fail if tag already exists
            try {
              await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `tags/${tag}`,
              });
              core.setFailed(`tag already exists: ${tag}`);
              return;
            } catch (e) {
              if (e.status !== 404) throw e;
            }

            await github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `refs/tags/${tag}`,
              sha: context.sha,
            });

      - name: "Publish/Update GitHub Release (tag: nightly or v*)"
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ needs.meta.outputs.release_tag }}
          name: ${{ needs.meta.outputs.is_nightly == 'true' && 'Nightly' || needs.meta.outputs.release_tag }}
          prerelease: ${{ needs.meta.outputs.prerelease == 'true' }}
          allowUpdates: ${{ needs.meta.outputs.is_nightly == 'true' }}
          replacesArtifacts: ${{ needs.meta.outputs.is_nightly == 'true' }}
          makeLatest: ${{ needs.meta.outputs.make_latest == 'true' }}
          immutableCreate: ${{ needs.meta.outputs.is_nightly != 'true' }}
          body: |
            Automated build.
            Version: ${{ needs.integration.outputs.version }}
            Commit:  ${{ github.sha }}
          artifacts: |
            dist/*
